<?php

/**
 * @file
 * harmony_core.module
 */

/**
 * Thread is not published.
 */
define('HARMONY_NOT_PUBLISHED', 0);

/**
 * Thread is published.
 */
define('HARMONY_PUBLISHED', 1);

/**
 * Thread is not pinned.
 */
define('THREAD_NOT_PINNED', 0);

/**
 * Thread is pinned at the top of listings.
 */
define('THREAD_PINNED', 1);

/**
 * Thread is not locked.
 */
define('HARMONY_NOT_LOCKED', 0);

/**
 * Thread is locked and cannot be posted on.
 */
define('HARMONY_LOCKED', 1);

/**
 * Modules should return this value from hook_thread_access() to allow access
 * to a thread or post.
 */
define('HARMONY_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_thread_access() to deny access
 * to a thread or post.
 */
define('HARMONY_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_thread_access() to not affect
 * access to a thread or post.
 */
define('HARMONY_ACCESS_IGNORE', NULL);

/**
 * Load includes.
 */
include_once 'harmony_core.features.inc';
module_load_include('inc', 'harmony_core', 'includes/harmony_core.controllers');
module_load_include('inc', 'harmony_core', 'includes/harmony_core.pathauto');

/**
 * Implements hook_entity_info().
 */
function harmony_core_entity_info() {
  $entities['harmony_thread'] = array(
    'label' => t('Thread'),
    'plural label' => t('Threads'),
    'entity class' => 'HarmonyThread',
    'controller class' => 'HarmonyThreadController',
    'base table' => 'harmony_thread',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'thread_id',
    ),
    'bundles' => array(
      'harmony_thread' => array(
        'label' => t('Thread'),
        'admin' => array(
          'path' => 'admin/structure/harmony/thread',
          'real path' => 'admin/structure/harmony/thread',
          'access arguments' => array('administer thread entity'),
        ),
      ),
    ),
    'load hook' => 'harmony_thread_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Default'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'harmony_core_thread_label',
    'uri callback' => 'harmony_core_thread_uri',
    'module' => 'harmony_core',
    'access callback' => 'harmony_core_thread_access_callback',
  );

  $entities['harmony_post'] = array(
    'label' => t('Post'),
    'plural label' => t('Posts'),
    'entity class' => 'HarmonyPost',
    'controller class' => 'HarmonyPostController',
    'base table' => 'harmony_post',
    'revision table' => 'harmony_post_revision',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'post_id',
      'revision' => 'vid',
    ),
    'bundles' => array(
      'harmony_post' => array(
        'label' => t('Post'),
        'admin' => array(
          'path' => 'admin/structure/harmony/post',
          'real path' => 'admin/structure/harmony/post',
          'access arguments' => array('administer post entity'),
        ),
      ),
    ),
    'load hook' => 'harmony_post_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Default'),
        'custom settings' => FALSE,
      ),
      // Used when showing an inline reply to a post.
      'inline_reply' => array(
        'label' => t('Inline Reply'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'harmony_core_post_label',
    'uri callback' => 'harmony_core_post_uri',
    'module' => 'harmony_core',
    'access callback' => 'harmony_core_post_access_callback',
    'inline entity form' => array(
      'controller' => 'HarmonyPostInlineEntityFormController',
    ),
  );

  return $entities;
}

function harmony_core_post_revision_access($op, $name, $entity = NULL, $account = NULL) {
  return $op == 'view' ? user_access('view post revisions', $account) : user_access('administer forum content', $account);
}

/**
 * Implements hook_entity_property_info().
 */
function harmony_core_entity_property_info() {
  $info = array();
  $thread_properties = &$info['harmony_thread']['properties'];

  $thread_properties['thread_id'] = array(
    'label' => t('Thread ID'),
    'type' => 'integer',
    'description' => t('The unique thread ID.'),
  );
  $thread_properties['title'] = array(
    'label' => t('Title'),
    'description' => t('The title of the thread.'),
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'title',
  );
  $thread_properties['uid'] = array(
    'label' => t('Author'),
    'type' => 'user',
    'description' => t('The author of the thread.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'required' => TRUE,
    'schema field' => 'uid',
  );
  $thread_properties['status'] = array(
    'label' => t('Status'),
    'description' => t('Whether the thread is published or unpublished.'),
    'type' => 'integer',
    'options list' => 'entity_metadata_status_options_list',
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'status',
  );
  $thread_properties['created'] = array(
    'label' => t('Date created'),
    'type' => 'date',
    'description' => t('The date the thread was created.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'created',
  );
  $thread_properties['updated'] = array(
    'label' => t('Date updated'),
    'type' => 'date',
    'description' => t('The date the thread was most recently updated.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'updated',
  );
  $thread_properties['pinned'] = array(
    'label' => t('Pinned'),
    'description' => t('Whether the thread should be displayed at the top of lists in which it appears.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'pinned',
    'type' => 'boolean',
  );
  $thread_properties['locked'] = array(
    'label' => t('Locked'),
    'description' => t('Whether the thread is locked from changes.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'locked',
    'type' => 'boolean',
  );
  $thread_properties['favourites'] = array(
    'label' => t('Favourites'),
    'description' => t('Number of times that the thread has been favourited.'),
    'type' => 'integer',
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'favourites',
  );
  $thread_properties['likes'] = array(
    'label' => t('Likes'),
    'description' => t('Number of times that posts within the thread have been liked.'),
    'type' => 'integer',
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'likes',
  );
  $thread_properties['views'] = array(
    'label' => t('Views'),
    'description' => t('Number of times the thread has been viewed.'),
    'type' => 'integer',
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'views',
  );

  // Post entity properties.
  $post_properties = &$info['harmony_post']['properties'];

  $post_properties['post_id'] = array(
    'label' => t('Post ID'),
    'type' => 'integer',
    'description' => t('The unique post ID.'),
  );
  $properties['vid'] = array(
    'label' => t('Revision ID'),
    'type' => 'integer',
    'description' => t("The unique ID of the post's revision."),
    'schema field' => 'vid',
  );
  $post_properties['title'] = array(
    'label' => t('Title'),
    'description' => t('The title of the thread.'),
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'title',
  );
  $post_properties['uid'] = array(
    'label' => t('Author'),
    'type' => 'user',
    'description' => t('The author of the post.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'required' => TRUE,
    'schema field' => 'uid',
  );
  $post_properties['status'] = array(
    'label' => t('Status'),
    'description' => t('Whether the post is published or unpublished.'),
    'type' => 'integer',
    'options list' => 'entity_metadata_status_options_list',
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'status',
  );
  $post_properties['created'] = array(
    'label' => t('Date created'),
    'type' => 'date',
    'description' => t('The date the post was created.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'created',
  );
  $post_properties['updated'] = array(
    'label' => t('Date updated'),
    'type' => 'date',
    'description' => t('The date the post was most recently updated.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'updated',
  );
  $post_properties['locked'] = array(
    'label' => t('Locked'),
    'description' => t('Whether the post is locked from changes.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer forum content',
    'schema field' => 'locked',
    'type' => 'boolean',
  );
  $post_properties['replies'] = array(
    'label' => t('Replies count'),
    'description' => t('Number of times that the post has been replied to.'),
    'type' => 'integer',
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'replies',
  );
  $post_properties['first_post'] = array(
    'label' => t('Is first post in thread'),
    'description' => t('Boolean indicating whether the post is the first within the thread.'),
    'type' => 'boolean',
    'setter callback' => 'entity_property_verbatim_set',
    'schema field' => 'first_post',
  );
  $post_properties['log'] = array(
    'label' => t('Revision log message'),
    'type' => 'text',
    'description' => t('In case a new revision is to be saved, the log entry explaining the changes for this version.'),
    'setter callback' => 'entity_property_verbatim_set',
    'access callback' => 'harmony_core_post_revision_access',
  );
  $post_properties['revision'] = array(
    'label' => t('Creates revision'),
    'type' => 'boolean',
    'description' => t('Whether saving this post creates a new revision.'),
    'setter callback' => 'entity_property_verbatim_set',
    'access callback' => 'harmony_core_post_revision_access',
  );

  return $info;
}

/**
 * Implements hook_permission().
 */
function harmony_core_permission() {
  return array(
    'administer harmony settings' => array(
      'title' => t('Administer Harmony settings'),
      'description' => t('Allows users to configure general settings for Harmony.'),
      'restrict access' => TRUE,
    ),
    'administer thread entity' => array(
      'title' => t('Administer thread entity'),
      'description' => t('Allows users to configure the thread entity type and its fields.'),
      'restrict access' => TRUE,
    ),
    'administer post entity' => array(
      'title' => t('Administer post entity'),
      'description' => t('Allows users to configure the post entity type and its fields.'),
      'restrict access' => TRUE,
    ),
    'administer forum content' => array(
      'title' => t('Administer forum content'),
      'description' => t('Allows users to create, edit and delete any forum threads or posts.'),
      'restrict access' => TRUE,
    ),
    'bypass forum access control' => array(
      'title' => t('Bypass forum access control'),
      'description' => t('Allows users to bypass access checks.'),
      'restrict access' => TRUE,
    ),
    'view threads' => array(
      'title' => t('View threads'),
      'description' => t('Allows users to view threads.'),
    ),
    'view unpublished threads' => array(
      'title' => t('View unpublished threads'),
      'description' => t('Allows users to view unpublished threads.'),
    ),
    'view own unpublished threads' => array(
      'title' => t('View own unpublished threads'),
      'description' => t('Allows users to view unpublished threads that they have created.'),
    ),
    'create threads' => array(
      'title' => t('Create new threads'),
      'description' => t('Allows users to create threads.'),
    ),
    'reply as new thread' => array(
      'title' => t('Reply as new thread'),
      'description' => t('Allows users to create threads.'),
    ),
    'edit any thread' => array(
      'title' => t('Edit any thread'),
      'description' => t('Allows users to edit any thread.'),
      'restrict access' => TRUE,
    ),
    'edit own threads' => array(
      'title' => t('Edit own threads'),
      'description' => t('Allows users to edit their own threads.'),
      'restrict access' => TRUE,
    ),
    'delete any thread' => array(
      'title' => t('Delete any thread'),
      'description' => t('Allows users to delete any threads.'),
      'restrict access' => TRUE,
    ),
    'delete own threads' => array(
      'title' => t('Delete own threads'),
      'description' => t('Allows users to delete own threads.'),
    ),
    'view posts' => array(
      'title' => t('View posts'),
      'description' => t('Allows users to view posts.'),
    ),
    'view unpublished posts' => array(
      'title' => t('View unpublished posts'),
      'description' => t('Allows users to view unpublished posts.'),
    ),
    'view own unpublished posts' => array(
      'title' => t('View own unpublished posts'),
      'description' => t('Allows users to view unpublished posts that they have created.'),
    ),
    'view post revisions' => array(
      'title' => t('View post revisions'),
      'description' => t('Allows users to view a posts revisions.'),
    ),
    'revert any post revisions' => array(
      'title' => t('Revert any post revisions'),
      'description' => t('Allows users to revert any post revisions.'),
    ),
    'delete any post revisions' => array(
      'title' => t('Delete any post revisions'),
      'description' => t('Allows users to delete any post revisions.'),
    ),
    'view own post revisions' => array(
      'title' => t('View own post revisions'),
      'description' => t('Allows users to view their own posts revisions.'),
    ),
    'revert own post revisions' => array(
      'title' => t('Revert own post revisions'),
      'description' => t('Allows users to revert their own post revisions.'),
    ),
    'delete own post revisions' => array(
      'title' => t('Delete own post revisions'),
      'description' => t('Allows users to delete their own post revisions.'),
    ),
    'create posts' => array(
      'title' => t('Create new posts'),
      'description' => t('Allows users to create posts.'),
    ),
    'edit any post' => array(
      'title' => t('Edit any post'),
      'description' => t('Allows users to edit any post.'),
      'restrict access' => TRUE,
    ),
    'edit own posts' => array(
      'title' => t('Edit own posts'),
      'description' => t('Allows users to edit their own posts.'),
      'restrict access' => TRUE,
    ),
    'delete any post' => array(
      'title' => t('Delete any post'),
      'description' => t('Allows users to delete any posts.'),
      'restrict access' => TRUE,
    ),
    'delete own posts' => array(
      'title' => t('Delete own posts'),
      'description' => t('Allows users to delete own posts.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function harmony_core_menu() {
  $items = array();

  $includes_dir = drupal_get_path('module', 'harmony_core') . '/includes';

  // Administration menu items.
  $items['admin/structure/harmony'] = array(
    'title' => 'Harmony',
    'access arguments' => array('administer harmony settings'),
    'page callback' => 'harmony_core_harmony_structure_settings',
    'file' => 'harmony_core.admin.inc',
    'file path' => $includes_dir,
    'weight' => -10,
  );

  $items['admin/structure/harmony/thread'] = array(
    'title' => 'Thread settings',
    'access arguments' => array('administer thread entity'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_thread_entity_form'),
    'file' => 'harmony_core.admin.inc',
    'file path' => $includes_dir,
    'weight' => 0,
  );

  $items['admin/structure/harmony/thread/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/harmony/post'] = array(
    'title' => 'Post settings',
    'access arguments' => array('administer post entity'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_post_entity_form'),
    'file' => 'harmony_core.admin.inc',
    'file path' => $includes_dir,
    'weight' => 1,
  );

  $items['admin/structure/harmony/post/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Standard CRUD menu items.
  $items['thread/add'] = array(
    'title' => 'Create thread',
    'page callback' => 'harmony_core_thread_add',
    'access arguments' => array('create threads'),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['thread/%harmony_thread'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('harmony_thread', 1),
    'page callback' => 'harmony_core_thread_view_page',
    'page arguments' => array(1),
    'access callback' => 'harmony_core_thread_access_callback',
    'access arguments' => array('view', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['thread/%harmony_thread/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['thread/%harmony_thread/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_thread_form', 1),
    'access callback' => 'harmony_core_thread_access_callback',
    'access arguments' => array('update', 1),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['thread/%harmony_thread/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_thread_delete_confirm', 1),
    'access callback' => 'harmony_core_thread_access_callback',
    'access arguments' => array('delete', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/add'] = array(
    'title' => 'Create post',
    'page callback' => 'harmony_core_post_add',
    'access arguments' => array('create posts'),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('harmony_post', 1),
    'page callback' => 'harmony_core_post_view_page',
    'page arguments' => array(1),
    'access callback' => 'harmony_core_post_access_callback',
    'access arguments' => array('view', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['post/%harmony_post/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_post_form', 1),
    'access callback' => 'harmony_core_post_access_callback',
    'access arguments' => array('update', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_post_delete_confirm', 1),
    'access callback' => 'harmony_core_post_access_callback',
    'access arguments' => array('delete', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'harmony_core_post_revisions_view',
    'page arguments' => array(1),
    'access callback' => 'harmony_core_post_revision_access_callback',
    'access arguments' => array('view', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
  );

  $items['post/%harmony_post/revisions/%/%ctools_js'] = array(
    'title callback' => 'harmony_core_post_revision_title',
    'title arguments' => array(1),
    'load arguments' => array(3),
    'page callback' => 'harmony_core_post_revision_view',
    'page arguments' => array(1, 3, 4),
    'access callback' => 'harmony_core_post_revision_access_callback',
    'access arguments' => array('view', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_post_revision_revert_confirm', 1),
    'access callback' => 'harmony_core_post_revision_access_callback',
    'access arguments' => array('update', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  $items['post/%harmony_post/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('harmony_core_post_revision_delete_confirm', 1),
    'access callback' => 'harmony_core_post_revision_access_callback',
    'access arguments' => array('delete', 1),
    'file' => 'harmony_core.pages.inc',
    'file path' => $includes_dir,
  );

  // Thread views counter.
  $items['thread/view/%'] = array(
    'title' => 'Thread view count logger',
    'page callback' => 'harmony_core_thread_log_view',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function harmony_core_theme($existing, $type, $theme, $path) {
  $module_dir = drupal_get_path('module', 'harmony_core');

  return array(
    'harmony_thread' => array(
      'render element' => 'elements',
      'template' => 'harmony-thread',
      'path' => $module_dir . '/theme',
    ),
    'harmony_post' => array(
      'render element' => 'elements',
      'template' => 'harmony-post',
      'path' => $module_dir . '/theme',
    ),
    'harmony_post_diff_inline_metadata' => array(
      'arguments' => array(
        'post' => NULL,
      ),
      'file' => 'harmony_core.theme.inc',
      'path' => $module_dir . '/theme',
    ),
  );
}

/**
 * Implements hook_cron().
 */
function harmony_core_cron() {
  db_delete('harmony_thread_read_history')
    ->condition('timestamp', harmony_core_thread_new_limit(), '<')
    ->execute();
}

/**
 * Implements hook_context_plugins().
 */
function harmony_core_context_plugins() {
  $plugins['harmony_core_context_condition_thread'] = array(
    'handler' => array(
      'path' => drupal_get_path('module', 'harmony_core') .'/includes',
      'file' => 'harmony_core.context.inc',
      'class' => 'harmony_core_context_condition_thread',
      'parent' => 'context_condition',
    ),
  );

  return $plugins;
}

/**
 * Implements hook_context_registry().
 */
function harmony_core_context_registry() {
  return array(
    'conditions' => array(
      'harmony_thread' => array(
        'title' => t('Threads'),
        'plugin' => 'harmony_core_context_condition_thread',
      ),
    ),
  );
}

/**
 * Determines whether the current user may perform the operation on the thread.
 *
 * @param $op
 *   The operation to be performed on the thread. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $entity
 *   The thread object on which the operation is to be performed.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function harmony_core_thread_access_callback($op, $entity, $account = NULL) {
  $rights = &drupal_static(__FUNCTION__, array());

  // Check that the operation is valid.
  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $entity_type = 'harmony_thread';

  // Use the best available identifier for the cache ID.
  if (is_object($entity)) {
    $cid = $entity->thread_id;
  }
  elseif (is_string($entity)) {
    $cid = $entity;
  }
  else {
    // Nothing to use, prevent caching.
    $cid = '';
    unset($rights[$account->uid][$cid][$op]);
  }

  // If we've already checked access for this entity, return from cache.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  // Don't allow anon to create content, putting here so it's very obvious! @todo
  if ($op == 'create' && !$account->uid) {
    return FALSE;
  }

  // Admin-ish access checks.
  if (user_access('bypass forum access control', $account) || user_access('administer forum content', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // We grant access to the thread if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  // If no module specified either allow or deny, we fall back to the
  // thread_access table.
  $access = module_invoke_all('harmony_thread_access', $op, $entity, $account, $entity_type);
  if (in_array(HARMONY_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(HARMONY_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  /* @todo Implement thread access grants. */
  if (module_exists('harmony_access')) {

  }

  return FALSE;
}

/**
 * Implements hook_harmony_thread_access().
 */
function harmony_core_harmony_thread_access($op, $entity, $account, $entity_type) {
  return harmony_core_entity_access_check($op, $entity, $account, $entity_type);
}

/**
 * A way for us to check access to an entity. Avoid the name
 * hook_entity_access in case a module like that comes along one day.
 */
function harmony_core_entity_access_check($op, $entity, $account, $entity_type) {
  switch ($op) {
    case 'view':
      if ($entity->status && user_access("view {$entity_type}s", $account) || !$entity->status && user_access("view unpublished {$entity_type}s", $account) || !$entity->status && $account->uid == $entity->uid && user_access("view own unpublished {$entity_type}s", $account)) {
        return HARMONY_ACCESS_ALLOW;
      }
    case 'update':
      if (user_access("edit any {$entity_type}", $account) || $entity && $account->uid == $entity->uid && user_access("edit own {$entity_type}s", $account)) {
        return HARMONY_ACCESS_ALLOW;
      }
    case 'delete':
      if (user_access("delete any {$entity_type}", $account) || $entity && $account->uid == $entity->uid && user_access("delete own {$entity_type}s", $account)) {
        return HARMONY_ACCESS_ALLOW;
      }
    case 'create':
      if (user_access("create {$entity_type}s", $account)) {
        return HARMONY_ACCESS_ALLOW;
      }
  }

  return HARMONY_ACCESS_IGNORE;
}

/**
 * Determines whether the current user may perform the operation on the post.
 *
 * @param $op
 *   The operation to be performed on the thread. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $entity
 *   The thread object on which the operation is to be performed.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @param $entity_type
 *   Optional, the type of entity passed in.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function harmony_core_post_access_callback($op, $entity, $account = NULL) {
  $rights = &drupal_static(__FUNCTION__, array());

  // Check that the operation is valid.
  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $entity_type = 'harmony_post';

  // Use the best available identifier for the cache ID.
  if (is_object($entity) && !empty($entity->post_id)) {
    $cid = $entity->post_id;
  }
  elseif (is_string($entity)) {
    $cid = $entity;
  }
  else {
    // Nothing to use, prevent caching.
    $cid = '';
    unset($rights[$account->uid][$cid][$op]);
  }

  // If we've already checked access for this entity, return from cache.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  // Don't allow anon to create content, putting here so it's very obvious!
  if ($op == 'create' && !$account->uid) {
    return FALSE;
  }

  // Admin-ish access checks.
  if (user_access('bypass forum access control', $account) || user_access('administer forum content', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // Check the operation perms via this generic function, also used
  // to check basic thread perms.
  $access = harmony_core_entity_access_check($op, $entity, $account, $entity_type);

  // The user must also have access to the thread they're trying to post in,
  // if the post is attached to a thread.
  if ($access == HARMONY_ACCESS_ALLOW) {
    $wrapper = entity_metadata_wrapper($entity_type, $entity);

    if ($wrapper->field_harmony_thread->value()) {
      $thread = harmony_thread_load($wrapper->field_harmony_thread->value());

      if (harmony_core_thread_access_callback('view', $thread, $account) != HARMONY_ACCESS_ALLOW) {
        $access = HARMONY_ACCESS_DENY;
      }
    }
  }

  // The user should have access to view the thread.
  if ($access === HARMONY_ACCESS_DENY) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // Allow custom access rules to jump in.
  /* @todo Implement post access grants. */
  if (module_exists('harmony_access')) {

  }

  return FALSE;
}

function harmony_core_post_revision_access_callback($op, $post, $account = NULL) {
  $rights = &drupal_static(__FUNCTION__, array());

  $map = array(
    'view' => 'view post revisions',
    'update' => 'revert any post revisions',
    'delete' => 'delete any post revisions',
  );

  if (!$post || !isset($map[$op])) {
    // If there was no post to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $cid = $post->vid;

  // If we've already checked access for this entity, return from cache.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  $is_current_revision = $post->vid === $post->current_vid;

  // Prevent deletion of the current revision.
  if ($is_current_revision && $op == 'delete') {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // Prevent reverting the current revision.
  if ($is_current_revision && $op == 'update') {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // If updating/reverting, then we need more than one revision.
  if ($op == 'update') {
    $revision_count = db_query('SELECT COUNT(vid) FROM {harmony_post_revision} WHERE post_id = :post_id', array(':post_id' => $post->post_id))->fetchField();

    if ($revision_count < 2) {
      $rights[$account->uid][$cid][$op] = FALSE;
      return FALSE;
    }
  }

  // Admin-ish access checks.
  if (user_access('bypass forum access control', $account) || user_access('administer forum content', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // Check that the specified user has access to the post, and in turn
  // view the thread.
  $post_access = harmony_core_post_access_callback($op, $post, $account);
  if ($post_access !== HARMONY_ACCESS_ALLOW) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // Global revision permissions.
  if (user_access($map[$op], $account) && $post_access === HARMONY_ACCESS_ALLOW) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // We're on to the path of $op "own", or more custom access control.
  $own_map = array(
    'view' => 'view own post revisions',
    'update' => 'revert own post revisions',
    'delete' => 'delete own post revisions',
  );

  if (user_access($own_map[$op], $account) && $post->uid === $account->uid) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  return FALSE;
}

function harmony_core_thread_label($entity, $entity_type) {
  return empty($entity->title) ? t('Untitled thread') : $entity->title;
}

function harmony_core_thread_uri($entity) {
  return array(
    'path' => 'thread/' . $entity->thread_id,
  );
}

/**
 * Load a thread.
 */
function harmony_thread_load($thread_id, $reset = FALSE) {
  $threads = harmony_thread_load_multiple(array($thread_id), array(), $reset);
  return reset($threads);
}

/**
 * Load multiple threads based on certain conditions.
 */
function harmony_thread_load_multiple($thread_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('harmony_thread', $thread_ids, $conditions, $reset);
}

/**
 * Save a thread.
 */
function harmony_thread_save($thread) {
  return entity_get_controller('harmony_thread')->save($thread);
}

/**
 * Delete a single thread.
 */
function harmony_thread_delete($thread_id) {
  harmony_thread_delete_multiple(array($thread_id));
}

/**
 * Delete multiple threads.
 */
function harmony_thread_delete_multiple($thread_ids) {
  entity_delete_multiple('harmony_thread', $thread_ids);
}

function harmony_core_post_label($entity, $entity_type) {
  return empty($entity->title) ? t('Untitled post') : $entity->title;
}

function harmony_core_post_uri($entity) {
  return array(
    'path' => 'post/' . $entity->post_id,
  );
}

/**
 * Load a post.
 */
function harmony_post_load($post_id, $vid = NULL, $reset = FALSE) {
  $conditions = !empty($vid) ? array('vid' => $vid) : array();
  $posts = harmony_post_load_multiple(array($post_id), $conditions, $reset);
  return reset($posts);
}

/**
 * Load multiple posts based on certain conditions.
 */
function harmony_post_load_multiple($post_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('harmony_post', $post_ids, $conditions, $reset);
}

/**
 * Save a post.
 */
function harmony_post_save($post) {
  return entity_get_controller('harmony_post')->save($post);
}

/**
 * Delete a single post.
 */
function harmony_post_delete($post_id) {
  harmony_post_delete_multiple(array($post_id));
}

/**
 * Delete multiple posts.
 */
function harmony_post_delete_multiple($post_ids) {
  entity_delete_multiple('harmony_post', $post_ids);
}

/**
 * Delete a post revision.
 */
function harmony_post_revision_delete($revision_id) {
  return entity_get_controller('harmony_post')->deleteRevision($revision_id);
}

/**
 * Implements hook_action_info().
 */
function harmony_core_action_info() {
  $actions = array(
    'harmony_core_thread_publish_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Publish thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_unpublish_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Unpublish thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_make_pinned_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Pin thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_make_unpinned_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Unpin thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_locked_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Lock thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_unlock_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Unlock thread'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_thread_save_action' => array(
      'type' => 'harmony_thread',
      'label' => t('Save thread'),
      'configurable' => FALSE,
      'triggers' => array(),
    ),
    'harmony_core_post_publish_action' => array(
      'type' => 'harmony_post',
      'label' => t('Publish post'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
    'harmony_core_post_unpublish_action' => array(
      'type' => 'harmony_post',
      'label' => t('Unpublish post'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
    ),
  );

  // @todo "delete" actions.

  // If pathauto is on, add in the update alias action
  // which lives in includes/harmony_core.pathauto.inc.
  if (module_exists('pathauto')) {
    $actions['harmony_core_thread_update_alias_action'] = array(
      'type' => 'harmony_thread',
      'label' => t('Update thread path alias'),
      'configurable' => FALSE,
    );
  }

  return $actions;
}

/**
 * Sets the status of a thread to 1 (published).
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_publish_action($thread, $context = array()) {
  $thread->status = HARMONY_PUBLISHED;
  watchdog('action', 'Set thread %title to published.', array('%title' => $thread->title));
  /* @todo queue unpublish of posts. */
}

/**
 * Sets the status of a thread to 0 (unpublished).
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_unpublish_action($thread, $context = array()) {
  $thread->status = HARMONY_NOT_PUBLISHED;
  watchdog('action', 'Set thread %title to unpublished.', array('%title' => $thread->title));
}

/**
 * Sets the pinned-at-top-of-list property of a thread to 1.
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_make_pinned_action($thread, $context = array()) {
  $thread->pinned = THREAD_PINNED;
  watchdog('action', 'Set thread %title to pinned.', array('%title' => $thread->title));
}

/**
 * Sets the pinned-at-top-of-list property of a thread to 0.
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_make_unpinned_action($thread, $context = array()) {
  $thread->pinned = THREAD_NOT_PINNED;
  watchdog('action', 'Set thread %title to unpinned.', array('%title' => $thread->title));
}

/**
 * Sets the locked property of a thread to 1.
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_locked_action($thread, $context = array()) {
  $thread->locked = HARMONY_LOCKED;
  watchdog('action', 'Locked the thread %title.', array('%title' => $thread->title));
}

/**
 * Sets the lock property of a thread to 0.
 *
 * @param $thread
 *   A thread object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_thread_unlock_action($thread, $context = array()) {
  $thread->locked = HARMONY_NOT_LOCKED;
  watchdog('action', 'Unlocked the thread %title .', array('%title' => $thread->title));
}

/**
 * Saves a thread.
 *
 * @param $thread
 *   The thread to be saved.
 *
 * @ingroup actions
 */
function harmony_core_thread_save_action($thread) {
  harmony_thread_save($thread);
  watchdog('action', 'Saved thread %title', array('%title' => $thread->title));
}

/**
 * Sets the status of a post to 1 (published).
 *
 * @param $post
 *   A post object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_post_publish_action($post, $context = array()) {
  $post->status = HARMONY_PUBLISHED;
  watchdog('action', 'Set post %title to published.', array('%title' => $post->title));
  /* @todo queue unpublish of posts. */
}

/**
 * Sets the status of a post to 0 (unpublished).
 *
 * @param $post
 *   A post object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function harmony_core_post_unpublish_action($post, $context = array()) {
  $post->status = HARMONY_NOT_PUBLISHED;
  watchdog('action', 'Set post %title to unpublished.', array('%title' => $post->title));
}

/**
 * Implements hook_cron_queue_info().
 */
function harmony_core_cron_queue_info() {
  $queues = array();

  $queues['update_post_title'] = array(
    'worker callback' => 'harmony_core_update_post_title',
    'time' => 120,
  );

  $queues['delete_posts'] = array(
    'worker callback' => 'harmony_post_delete',
    'time' => 120,
  );

  return $queues;
}

/**
 * Thread add/edit form callback.
 */
function harmony_core_thread_form($form, &$form_state, $thread) {
  $form = array();

  $form['thread'] = array(
    '#type' => 'value',
    '#value' => $thread,
  );
  $form['#attributes']['class'][] = 'thread-form';

  if (empty($thread->is_new)) {
    $thread->is_new = FALSE;
  }

  // Prevent users from editing a locked thread.
  if ($thread->locked && !user_access('administer forum content')) {
    drupal_access_denied();
  }

  // Basic thread information.
  // These elements are just values so they are not even sent to the client.
  foreach (array('thread_id', 'uid', 'is_new') as $key) {
    $form[$key] = array(
      '#type' => 'value',
      '#value' => isset($thread->$key) ? $thread->$key : NULL,
    );
  }

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Thread title'),
    '#required' => TRUE,
    '#default_value' => $thread->title,
    '#attributes' => array(
      'placeholder' => t('Thread title'),
    ),
    '#title_display' => 'invisible',
  );

  // Attach fields.
  field_attach_form('harmony_thread', $thread, $form, $form_state);

  // Options for administrators
  $form['options'] = array(
    '#type' => 'fieldset',
    '#access' => user_access('administer forum content'),
    '#title' => t('Thread options'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('thread-form-options'),
    ),
    '#weight' => 95,
  );
  $form['options']['status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Published'),
    '#default_value' => $thread->status,
  );
  $form['options']['pinned'] = array(
    '#type' => 'checkbox',
    '#title' => t('Pin to the top of listings'),
    '#default_value' => $thread->pinned,
  );
  $form['options']['locked'] = array(
    '#type' => 'checkbox',
    '#title' => t('Lock from replies'),
    '#default_value' => $thread->locked,
  );

  // Get field language as per http://tinyurl.com/ohsjheh stack exchange post.
  $first_post_lang = $form['field_harmony_first_post']['#language'];

  // Remove the fielset.
  $form['field_harmony_first_post'][$first_post_lang]['#type'] = 'markup';

  // Hide property-ish type fields that we don't want user 1 to see.
  $form['field_harmony_last_user_to_reply']['#access'] = FALSE;
  $form['field_harmony_post_count']['#access'] = FALSE;
  $form['field_harmony_thread_cont_from']['#access'] = FALSE;

  // Add the buttons.
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => $thread->is_new ? t('Create thread') : t('Save thread'),
    '#weight' => 5,
    '#submit' => array('harmony_core_thread_form_submit'),
  );
  if (!empty($thread->thread_id) && harmony_core_thread_access_callback('delete', $thread)) {
    $form['actions']['delete'] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#weight' => 15,
      '#submit' => array('harmony_thread_delete_submit'),
    );
  }

  return $form;
}

/**
 * Validation handler for harmony_core_thread_form.
 * We pass things straight through to the Field API to handle validation
 * of the attached fields.
 */
function harmony_core_thread_form_validate($form, &$form_state) {
  field_attach_form_validate('harmony_thread', $form_state['values']['thread'], $form, $form_state);
}

/**
 * Form submit handler for harmony_core_thread_form.
 */
function harmony_core_thread_form_submit($form, &$form_state) {
  $thread = $form_state['values']['thread'];
  $is_new = $thread->is_new;
  $wrapper = entity_metadata_wrapper('harmony_thread', $thread);

  $wrapper->title->set($form_state['values']['title']);

  $wrapper->status->set($form_state['values']['status']);
  $wrapper->pinned->set($form_state['values']['pinned']);
  $wrapper->locked->set($form_state['values']['locked']);

  field_attach_submit('harmony_thread', $thread, $form, $form_state);

  // If saving a new thread then set the first instance of
  // the last user to update field.
  if ($is_new) {
    $wrapper->field_harmony_last_user_to_reply->set($thread->uid);
    //$wrapper->field_harmony_post_count->set(1);
  }

  $thread = harmony_thread_save($thread);

  // Set various bits of data on the first post.
  // Other values are set in HarmonyPostInlineEntityFormController::entityFormSubmit().
  if ($is_new && $wrapper->field_harmony_first_post->value()) {
    $wrapper->field_harmony_first_post->title->set($thread->title);
    $wrapper->field_harmony_first_post->field_harmony_thread->set($thread->thread_id);
    $wrapper->field_harmony_first_post->save();
  }

  $form_state['redirect'] = "thread/$thread->thread_id";
}

/**
 * Post add/edit form callback.
 */
function harmony_core_post_form($form, &$form_state, $post) {
  $form = array();

  $form['post'] = array(
    '#type' => 'value',
    '#value' => $post,
  );
  $form['#attributes']['class'][] = 'post-form';

  if (empty($post->is_new)) {
    $post->is_new = FALSE;
    $wrapper = entity_metadata_wrapper('harmony_post', $post);

    if ($wrapper->field_harmony_thread->value()) {
      // Prevent users from editing within a locked thread.
      if ($wrapper->field_harmony_thread->locked->value()) {
        drupal_access_denied();
      }
    }
  }

  // Prevent users from editing a locked post.
  if ($post->locked && !user_access('administer forum content')) {
    drupal_access_denied();
  }

  // Basic post information.
  // These elements are just values so they are not even sent to the client.
  foreach (array('post_id', 'uid', 'is_new') as $key) {
    $form[$key] = array(
      '#type' => 'value',
      '#value' => isset($post->$key) ? $post->$key : NULL,
    );
  }

  $form['title'] = array(
    '#type' => 'value',
    '#title' => t('Post title'),
    '#default_value' => $post->title,
  );

  // Attach fields.
  field_attach_form('harmony_post', $post, $form, $form_state);

  // Options for administrators
  $form['options'] = array(
    '#type' => 'fieldset',
    '#access' => user_access('administer forum content'),
    '#title' => t('Post options'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('post-form-options'),
    ),
    '#weight' => 95,
  );
  $form['options']['status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Published'),
    '#default_value' => $post->status,
  );
  $form['options']['locked'] = array(
    '#type' => 'checkbox',
    '#title' => t('Lock from edits'),
    '#default_value' => $post->locked,
  );

  // Add in the log for revisions, if not new.
  if (empty($post->is_new) || !empty($post->is_new) && !$post->is_new) {
    $form['options']['log'] = array(
      '#type' => 'textarea',
      '#title' => t('Reason for edit'),
      '#rows' => 4,
    );
  }
  else {
    $form['options']['log'] = array(
      '#type' => 'value',
      '#value' => NULL,
    );
  }

  // Add the buttons.
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => $post->is_new ? t('Reply') : t('Save post'),
    '#weight' => 5,
    '#submit' => array('harmony_core_post_form_submit'),
  );
  if (!empty($post->post_id) && harmony_core_post_access_callback('delete', $post)) {
    $form['actions']['delete'] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#weight' => 15,
      '#submit' => array('harmony_post_delete_submit'),
    );
  }

  return $form;
}

/**
 * Validation handler for harmony_core_post_form.
 * We pass things straight through to the Field API to handle validation
 * of the attached fields.
 */
function harmony_core_post_form_validate($form, &$form_state) {
  field_attach_form_validate('harmony_post', $form_state['values']['post'], $form, $form_state);
}

/**
 * Form submit handler for harmony_core_post_form.
 */
function harmony_core_post_form_submit($form, &$form_state) {
  $post = $form_state['values']['post'];
  $wrapper = entity_metadata_wrapper('harmony_post', $post);

  $wrapper->status->set($form_state['values']['status']);
  $wrapper->locked->set($form_state['values']['locked']);
  $wrapper->log->set($form_state['values']['log']);

  field_attach_submit('harmony_post', $post, $form, $form_state);

  $post = harmony_post_save($post);
  $form_state['redirect'] = "post/$post->post_id";
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function harmony_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Post content type.
  if ($form['#node']->type == 'post') {
    // Hide the title field and make other changes.
    _harmony_core_post_form_alter($form);

    // Change the submit button text.
    $form['submit']['#value'] = t('Post reply');
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Hide the thread count field.
 */
function harmony_core_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
  // @todo restrict to only harmony_category vocab, duh.
  $form['field_harmony_thread_count']['#access'] = FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Hides the thread and post count fields.
 */
function harmony_core_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  $form['field_harmony_thread_count']['#access'] = FALSE;
  $form['field_harmony_post_count']['#access'] = FALSE;
}

/**
 * Helper function to hide the title field.
 */
function _harmony_core_post_form_alter(&$form) {
  // Make title not required as we'll update this with rules. We can't
  // set this via the thread entity reference due to the first post case,
  // where the thread entity isn't yet saved.
  $form['title']['#type'] = 'value';
  $form['title']['#required'] = FALSE;

  // Hide the text label.
  $post_text_lang = !empty($form['field_harmony_text']['#language']) ? $form['field_harmony_text']['#language'] : NULL;
  if ($post_text_lang) {
    $form['field_harmony_text'][$post_text_lang][0]['#title_display'] = 'invisible';
  }
}

/**
 * Implements hook_thread_update().
 */
function harmony_core_harmony_thread_update($thread) {
  list($thread_id) = entity_extract_ids('harmony_thread', $thread);
  $wrapper = entity_metadata_wrapper('harmony_thread', $thread);

  // @todo checking for publish/unpublish and adjust post count
  // accordingly, use $entity->original.

  // Update the title of posts in this thread if it's changed, we do
  // this for administrative ease and because we use the title in places
  // like when rendering a search result.
  /*if ($wrapper->title->value() != $wrapper->field_harmony_first_post->title->value()) {
    $title = $wrapper->title->value();

    // Get a list of post nodes to update.
    $posts = db_query("SELECT entity_id
      FROM {field_data_field_harmony_thread}
      WHERE entity_type = 'node'
      AND bundle = 'harmony_post'
      AND field_harmony_thread_target_id = :thread_id",
      array(':thread_id' => $thread_id))->fetchAllAssoc('entity_id');

    // We've got a list of nodes.
    if (!empty($posts)) {
      // As per node_mass_update() if the list is less than 10,
      // process now, else queue and update on Cron run.
      $post_nids = array_keys($posts);

      if (count($post_nids) <= 10) {
        // Load the post nodes.
        $posts = entity_load('node', $post_nids);

        foreach ($posts as $post) {
          $post->title = $title;
          node_save($post);
        }
      }
      else {
        // Process these nodes in a queue.
        $queue = DrupalQueue::get('update_post_title');

        foreach ($post_nids as $nid) {
          $item = array(
            'nid' => $nid,
            'title' => $title,
          );

          $queue->createItem($item);
        }
      }
    }
  }*/
}

function harmony_core_harmony_thread_delete($thread) {
  list($thread_id) = entity_extract_ids('harmony_thread', $thread);

  // @todo this needs to live in the entity controller.

  // Remove all of the attached posts, first unpublish and orphan,
  // then batch delete, this way on hook_node_delete the thread
  // entity ref will be empty and no attempt will be made to update
  // it's metadata. SOLR remove.

  // Get a list of post nodes to delete.
  /*$posts = db_query("SELECT entity_id
    FROM {field_data_field_harmony_thread}
    WHERE entity_type = 'node'
    AND bundle = 'harmony_post'
    AND field_thread_target_id = :thread_id",
    array(':thread_id' => $thread_id))->fetchAllAssoc('entity_id');

  // Delete post revisions too.

  // We've got a list of nodes.
  if (!empty($posts)) {
    // As per node_mass_update() if the list is less than 10,
    // process now, else queue and update on Cron run.
    $post_nids = array_keys($posts);

    if (count($post_nids) <= 10) {
      // Load the post nodes.
      node_delete_multiple($post_nids);
    }
    else {
      // Process these nodes in a queue.
      $queue = DrupalQueue::get('delete_posts');

      foreach ($post_nids as $nid) {
        $queue->createItem($nid);
      }
    }
  }*/

  pathauto_entity_path_delete_all('harmony_thread', $thread, "thread/{$thread->thread_id}");

  entity_delete('harmony_thread', entity_id('harmony_thread' ,$thread));
}

/**
 * Update a thread or post count value.
 *
 * @param array $fields
 *   Fields to iterate over and set, could be one or multiple.
 * @param string $entity_type
 * @param integer $entity_id
 * @param string $op
 *   Operation string, will either be increment, decrement or set.
 * @param integer $value
 *   The value to increment, decrement or set the count value by/to.
 *
 */
function harmony_core_update_meta_count($fields, $entity_type, $entity_id, $op = 'increment', $value = 1) {
  if (empty($fields) || !is_numeric($value)) {
    return;
  }

  // Reload the entity not from cache so that entity metadata
  // wrapper is working from the latest data.
  // Would use entity_load_single if it had the params we need.
  $entities = entity_load($entity_type, array($entity_id), array(), TRUE);

  if (empty($entities[$entity_id])) {
    return;
  }

  // Create a wrapper.
  $wrapper = entity_metadata_wrapper($entity_type, $entities[$entity_id]);

  if (!$wrapper) {
    return;
  }

  // Loop through the specified fields.
  foreach ($fields as $field) {
    switch ($op) {
      case 'increment':
        $count = $wrapper->{$field}->value() + $value;
        $wrapper->{$field}->set($count);

        break;
      case 'decrement':
        $count = $wrapper->{$field}->value() + $value;
        $wrapper->{$field}->set($count);

        break;

      case 'set':
        $wrapper->{$field}->set($value);

        break;
    }
  }

  // Save our changes.
  $wrapper->save();
}

/**
 * Helper function to update a posts title.
 */
function harmony_core_update_post_title($item) {
  $post = entity_load_single('harmony_post', $item['post_id']);
  $post->title = $item['title'];
  node_save($post);
}

/**
 * Implements hook_node_insert().
 */
function harmony_core_node_insert($node) {
  if ($node->type == 'harmony_post') {
    $post = entity_metadata_wrapper('node', $node);

    // Get the thread id.
    $thread_id = $post->field_harmony_thread->value();

    // The thread id should be populated, if not then it's because
    // it's the first post in a thread.
    if ($thread_id) {
      // Set the last time the thread was updated.
      $post->field_harmony_thread->updated->set(REQUEST_TIME);
      // Set the last user to update the thread field.
      $post->field_harmony_thread->field_harmony_last_user_to_reply->set($node->uid);
      // Save the thread.
      $post->field_harmony_thread->save();

      // Increment the thread post count.
      harmony_core_update_meta_count(array('field_harmony_post_count'), 'harmony_thread', $thread_id);

      // Increment users post count.
      harmony_core_update_meta_count(array('field_harmony_post_count'), 'user', $node->uid);
    }
  }
}

/**
 * Implements hook_node_update().
 */
function harmony_core_node_update($node) {
  if ($node->type == 'harmony_post') {
    $post = entity_metadata_wrapper('node', $node);
    $thread_id = $post->field_harmony_thread->value();

    if ($thread_id) {
      // @todo, check that this post is published.

      // Update the thread's last active user if not current.
      if ($post->field_harmony_thread->field_harmony_last_user_to_reply->value() != $node->uid) {
        $post->field_harmony_thread->field_harmony_last_user_to_reply->set($node->uid);
      }

      // Update the thread's last updated time.
      $post->field_harmony_thread->updated->set(REQUEST_TIME);

      // Save changes.
      $post->field_harmony_thread->save();
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function harmony_core_node_delete($node) {
  if ($node->type == 'harmony_post') {
    $post = entity_metadata_wrapper('node', $node);
    $thread_id = $post->field_harmony_thread->value();

    if ($thread_id) {
      // Decrement the thread post count.
      harmony_core_update_meta_count(array('field_harmony_post_count'), 'harmony_thread', $thread_id, 'decrement');
    }

    // Increment users post count.
    harmony_core_update_meta_count(array('field_harmony_post_count'), 'user', $node->uid);
  }
}

/**
 * Threads changed before this time are always marked as read.
 *
 * Threads changed after this time may be marked new, updated, or read, depending
 * on their state for the current user. Defaults to 30 days ago.
 */
function harmony_core_thread_new_limit() {
  // As per node, default to 30 days.
  return REQUEST_TIME - variable_get('harmony_core_thread_new_limit', 2592000);
}

/**
 * Updates the 'last viewed' timestamp of the specified thread for current user.
 *
 * @param $thread
 *   A harmony_core_thread object.
 */
function harmony_core_thread_last_read_set($thread) {
  global $user;
  if ($user->uid) {
    db_merge('harmony_thread_read_history')
      ->key(array(
        'uid' => $user->uid,
        'thread_id' => $thread->thread_id,
      ))
      ->fields(array('timestamp' => REQUEST_TIME))
      ->execute();
   }
}

/**
 * Retrieves the timestamp for the current user's last view of a specified thread.
 *
 * @param $thread_id
 *   A harmony_core_thread ID.
 *
 * @return
 *   If a harmony_core_thread has been previously viewed by the user, the timestamp in seconds
 *   of when the last view occurred; otherwise, zero.
 */
function harmony_core_thread_last_read($thread_id) {
  global $user;
  $history = &drupal_static(__FUNCTION__, array());

  if (!isset($history[$thread_id])) {
    $history[$thread_id] = db_query("SELECT timestamp FROM {harmony_thread_read_history} WHERE uid = :uid AND thread_id = :thread_id", array(':uid' => $user->uid, ':thread_id' => $thread_id))->fetchObject();
  }

  return (isset($history[$thread_id]->timestamp) ? $history[$thread_id]->timestamp : 0);
}

/**
 * Finds the last time a thread was updated.
 *
 * @param $thread_id
 *   The ID of a thread.
 *
 * @return
 *   A unix timestamp indicating the last time the thread was updated.
 */
function harmony_core_thread_last_updated($thread_id) {
  return db_query('SELECT updated FROM {harmony_thread} WHERE thread_id = :thread_id', array(':thread_id' => $thread_id))->fetch()->updated;
}

/**
 * Determines the type of marker to be displayed for a given thread.
 *
 * @param $thread_id
 *   Node ID whose history supplies the "last viewed" timestamp.
 * @param $timestamp
 *   Time which is compared against the thread's "last viewed" timestamp.
 *
 * @return
 *   One of the MARK constants.
 * @see
 *   includes/theme.inc for the constants definitions.
 */
function harmony_core_thread_mark($thread_id, $timestamp) {
  global $user;
  $cache = &drupal_static(__FUNCTION__, array());
  $new_limit = harmony_core_thread_new_limit();

  if (!$user->uid) {
    return MARK_READ;
  }

  if (!isset($cache[$thread_id])) {
    $cache[$thread_id] = harmony_core_thread_last_read($thread_id);
  }

  if ($cache[$thread_id] == 0 && $timestamp > $new_limit) {
    return MARK_NEW;
  }
  elseif ($timestamp > $cache[$thread_id] && $timestamp > $new_limit) {
    return MARK_UPDATED;
  }

  return MARK_READ;
}

function harmony_core_mass_update($type, $entities, $op, $properties) {
  if (count($entities) > 10) {
    $batch = array(
      'operations' => array(
        array('_harmony_core_mass_update_batch_process', array($type, $entities, $op, $properties))
      ),
      'finished' => '_harmony_core_mass_update_batch_finished',
      'title' => t('Processing'),
      // We use a single multi-pass operation, so the default
      // 'Remaining x of y operations' message will be confusing here.
      'progress_message' => '',
      'error_message' => t('The update has encountered an error.'),
    );
    batch_set($batch);
  }
  else {
    foreach ($entities as $entity) {
      list($entity_id) = entity_extract_ids($type, $entity);
      _harmony_core_mass_update_small_set_process($type, $entity_id, $op, $properties);
    }

    drupal_set_message(t('The update has been performed.'));
  }
}

function _harmony_core_mass_update_helper($type, $entity_id, $op, $properties) {
  $load_function = "{$type}_load";
  $entity = $load_function($entity_id, TRUE);

  switch ($op) {
    case 'update':
      $entity->original = clone $entity;
      foreach ($updates as $name => $value) {
        $entity->$name = $value;
      }

      $save_function = "{$type}_save";
      save_function($entity);

      break;

    case 'delete':
      $delete_function = "{$type}_delete";
      $delete_function($entity);

      break;
  }

  return $entity;
}

/**
 * Executes a batch operation for harmony_core_mass_update().
 *
 * @param string $type
 *   A string defining the type of entity being processed.
 * @param array $entities
 *   An array of entity IDs.
 * @param array $updates
 *   Associative array of updates.
 * @param array $context
 *   An array of contextual key/values.
 */
function _harmony_core_mass_update_batch_process($type, $entities, $op, $properties, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($entities);
    $context['sandbox']['entities'] = $entities;
  }

  // Process nodes by groups of 5.
  $count = min(5, count($context['sandbox']['entities']));
  for ($i = 1; $i <= $count; $i++) {
    $entity_id = array_shift($context['sandbox']['entities']);
    $entity = _harmony_core_mass_update_helper($type, $entity_id, $op, $properties);

    // Store result for post-processing in the finished callback.
    $uri = entity_uri($type, $entity);
    $context['results'][] = l($entity->title, $uri);

    // Update our progress information.
    $context['sandbox']['progress']++;
  }

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Menu callback: Reports the status of batch operation for harmony_core_mass_update().
 *
 * @param bool $success
 *   A boolean indicating whether the batch mass update operation successfully
 *   concluded.
 * @param int $results
 *   The number of nodes updated via the batch mode process.
 * @param array $operations
 *   An array of function calls (not used in this function).
 */
function _harmony_core_mass_update_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The update has been performed.'));
  }
  else {
    drupal_set_message(t('An error occurred and processing did not complete.'), 'error');
    $message = format_plural(count($results), '1 item successfully processed:', '@count items successfully processed:');
    $message .= theme('item_list', array('items' => $results));
    drupal_set_message($message);
  }
}

/**
 * Implements hook_user_cancel().
 */
function harmony_core_user_cancel($edit, $account, $method) {
  // @todo - this function.
  switch ($method) {
    case 'user_cancel_block_unpublish':
      // Unpublish/unapprove threads.
      module_load_include('inc', 'node', 'node.admin');
      $threads = db_select('harmony_thread', 't')
        ->fields('t', array('thread_id'))
        ->condition('uid', $account->uid)
        ->execute()
        ->fetchCol();
      harmony_core_mass_update('harmony_thread', 'update', $threads, array('status' => 0));
      break;

    case 'user_cancel_reassign':
      /* @todo, you've left node business all in here! */
      // Anonymize threads.
      module_load_include('inc', 'node', 'node.admin');
      $nodes = db_select('harmony_thread', 't')
        ->fields('t', array('thread_id'))
        ->condition('uid', $account->uid)
        ->execute()
        ->fetchCol();
      node_mass_update($threads, array('uid' => 0));
      // Anonymize old revisions.
      /*db_update('thread_revision')
        ->fields(array('uid' => 0))
        ->condition('uid', $account->uid)
        ->execute();*/
      // Clean history.
      db_delete('harmony_thread_read_history')
        ->condition('uid', $account->uid)
        ->execute();
      break;
  }
}

/**
 * Implements hook_user_delete().
 */
function harmony_core_user_delete($account) {
  // Delete threads.
  $threads = db_select('harmony_thread', 't')
    ->fields('t', array('thread_id'))
    ->condition('uid', $account->uid)
    ->execute()
    ->fetchCol();
  harmony_core_mass_update('harmony_thread', 'delete', $threads, array());

  // Delete old revisions.
  /*$revisions = db_query('SELECT vid FROM {thread_revision} WHERE uid = :uid', array(':uid' => $account->uid))->fetchCol();
  foreach ($revisions as $revision) {
    node_revision_delete($revision);
  }*/

  // Clean history.
  db_delete('harmony_thread_read_history')
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_page_alter().
 *
 * View tracking for threads and anonymous users.
 */
function harmony_core_page_alter(&$page) {
  global $user;
  global $_harmony;

  // Only track thread pages, also check for a global do not track flag.
  if (!(arg(0) == 'thread' && is_numeric(arg(1)) && !arg(2)) || isset($_harmony['thread_do_not_track'])) {
    return;
  }

  // Load the thread and check access.
  $thread = harmony_thread_load(arg(1));
  $can_access_thread = $thread && harmony_core_thread_access_callback('view', $thread);

  if (!$can_access_thread) {
    return;
  }

  // Track the thread view immediately for authenticated users.
  if ($user->uid) {
    harmony_core_thread_track_view($thread->thread_id);
  }
  // For anonymous use the tracking image method due to page caching.
  else {
    $page['page_bottom']['harmony_core']['thread_view']['#markup'] = '<div class="element-hidden"><img src="' . url('thread/view/' . arg(1)) . '" alt="" /></div>';
  }
}

function harmony_core_thread_track_view($thread_id) {
  if (!empty($thread_id) && is_numeric($thread_id) && $thread_id > 0) {
    // Increment via db query.
    $transaction = db_transaction();

    try {
      db_query('UPDATE {harmony_thread} SET views = views + 1 WHERE thread_id = :thread_id', array(':thread_id' => $thread_id));
    }
    catch (Exception $e) {
      $transaction->rollback();
      watchdog_exception('harmony_core', $e);
    }
  }
}

/**
 * Menu callback function.
 *
 * Increment the number of views counter property on a thread.
 */
function harmony_core_thread_log_view($thread_id) {
  global $base_root;
  $thread = NULL;

  // Determine if the tracking request came from this site, or at least looks that way.
  $valid_referer = !empty($_SERVER['HTTP_REFERER']) && strpos($_SERVER['HTTP_REFERER'], $base_root) === 0;

  // Check the id is numeric.
  if ($valid_referer && !empty($thread_id) && is_numeric($thread_id) && $thread_id > 0) {
    // Load the thread.
    $thread = harmony_thread_load($thread_id);
  }

  // Check that the id is for a valid thread and that the user has access to it, then track.
  if ($thread && harmony_core_thread_access_callback('view', $thread)) {
    harmony_core_thread_track_view($thread->thread_id);
  }

  // Return a gif along with headers preventing caching.
  header('Content-type: image/gif');
  header('Expires: Sun, 19 Nov 1978 05:00:00 GMT');
  header('Cache-Control: no-cache');
  header('Cache-Control: no-store');
  header('Cache-Control: must-revalidate');
  header('Cache-Control: post-check=0');
  header('Cache-Control: pre-check=0');
  header('Content-Length: 0');
  header('Connection: close');

  // Bail out.
  drupal_exit();
}
